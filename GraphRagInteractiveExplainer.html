<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>インタラクティブ解説: GraphRag</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- Chosen Palette: "Calm Harmony" - A palette of warm neutrals (#F5F5F4 for background), a gentle dark tone for text (#44403C), and a subtle, earthy accent color (#A8A29E). -->
    <!-- Application Structure Plan: The application is designed as a single-page, top-to-bottom narrative journey. It starts with a high-level introduction, then contrasts traditional RAG with GraphRag. The core of the experience is an interactive, step-by-step visualization of the GraphRag process, allowing users to actively participate in building and querying a knowledge graph. This is followed by a clear presentation of benefits and use cases. This thematic, guided structure was chosen over a dashboard to make a complex technical concept accessible and engaging for learners, turning passive reading into an active learning process. -->
    <!-- Visualization & Content Choices: 1. RAG vs. GraphRag Process: Goal=Compare. Method=Side-by-side animated diagram (HTML/CSS/JS). Interaction=Scroll-triggered animation. Justification=Visually demonstrates the fundamental difference in information retrieval (linear vs. network). 2. Knowledge Graph Simulation: Goal=Organize/Relationships. Method=Interactive Canvas diagram (Chart.js). Interaction=User clicks buttons to trigger steps (Node Extraction, Edge Creation, Querying). Justification=Provides a hands-on, memorable experience of how a knowledge graph is constructed and used, which is far more effective than a static image. 3. Benefits: Goal=Inform. Method=Card layout with icons (Unicode). Interaction=Subtle hover effects. Justification=Breaks down key takeaways into digestible, visually appealing chunks. -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body {
            font-family: 'Inter', 'Noto Sans JP', sans-serif;
            background-color: #F5F5F4; /* Warm Neutral */
            color: #44403C; /* Gentle Dark */
        }
        .accent-bg { background-color: #A8A29E; }
        .accent-text { color: #A8A29E; }
        .accent-border { border-color: #A8A29E; }
        .card {
            background-color: #FFFFFF;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -2px rgb(0 0 0 / 0.1);
        }
        .btn {
            display: inline-block;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            background-color: #44403C;
            color: #FFFFFF;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .btn:hover {
            background-color: #1C1917;
        }
        .btn-outline {
            background-color: transparent;
            color: #44403C;
            border: 2px solid #A8A29E;
        }
        .btn-outline:hover {
            background-color: #A8A29E;
            color: #FFFFFF;
        }
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 700px;
            margin-left: auto;
            margin-right: auto;
            height: 300px;
            max-height: 400px;
        }
        @media (min-width: 768px) {
            .chart-container {
                height: 400px;
                max-height: 500px;
            }
        }
    </style>
</head>
<body class="antialiased">

    <header class="py-6 px-4 md:px-8 text-center">
        <h1 class="text-4xl md:text-5xl font-bold tracking-tight text-stone-900">GraphRag</h1>
        <p class="mt-3 text-lg md:text-xl text-stone-600 max-w-3xl mx-auto">RAGの精度を飛躍的に向上させる、関係性に着目した次世代フレームワーク</p>
    </header>

    <main class="container mx-auto px-4 py-8 md:py-12">

        <section id="intro" class="mb-16 md:mb-24">
            <div class="max-w-4xl mx-auto text-center">
                <h2 class="text-3xl font-bold mb-4">なぜ今、GraphRagなのか？</h2>
                <p class="text-lg text-stone-700 leading-relaxed">
                    大規模言語モデル(LLM)は強力ですが、その知識は学習データに限定されます。この課題を解決する「RAG」は、外部データでLLMを補強する技術です。しかし、従来のRAGは情報の「点」しか見つけられませんでした。GraphRagは、情報同士の「つながり」を理解することで、より深く、正確な答えを導き出します。このページでは、その仕組みをインタラクティブに探求します。
                </p>
            </div>
        </section>

        <section id="comparison" class="mb-16 md:mb-24">
            <div class="grid md:grid-cols-2 gap-8 md:gap-12 items-center">
                <div class="p-6 card">
                    <h3 class="text-2xl font-bold mb-3">従来のRAG</h3>
                    <p class="mb-4 text-stone-600">質問に最も「似ている」情報の断片をキーワードやベクトルで検索します。関連性は高いですが、文脈を見失うことがあります。</p>
                    <div class="font-mono text-sm p-4 bg-stone-100 rounded-lg">
                        <p><span class="font-bold">質問:</span> ジェミ助の開発者は？</p>
                        <p class="mt-2"><span class="font-bold">→ 検索:</span> "ジェミ助" "開発者"</p>
                        <p class="mt-2"><span class="font-bold">→ 発見:</span> 「...Googleがジェミ助を開発...」</p>
                        <p class="mt-2 text-red-500"><span class="font-bold">→ 見逃し:</span> (別文書)「...ジェミ助はLLMの一種...」</p>
                    </div>
                </div>
                <div class="p-6 card border-2 accent-border">
                    <h3 class="text-2xl font-bold mb-3">GraphRag</h3>
                    <p class="mb-4 text-stone-600">事前に情報全体の「関係図（ナレッジグラフ）」を作成。質問に関連する情報とその周辺情報をまとめて取得します。</p>
                     <div class="font-mono text-sm p-4 bg-stone-100 rounded-lg">
                        <p><span class="font-bold">質問:</span> ジェミ助の開発者は？</p>
                        <p class="mt-2"><span class="font-bold">→ グラフ探索:</span> [ジェミ助]ノード</p>
                        <p class="mt-2"><span class="font-bold">→ 発見:</span> [ジェミ助] -[開発者]-> [Google]</p>
                        <p class="mt-2 text-green-600"><span class="font-bold">→ 同時取得:</span> [ジェミ助] -[種類]-> [LLM]</p>
                    </div>
                </div>
            </div>
        </section>

        <section id="interactive-demo" class="text-center mb-16 md:mb-24 p-6 md:p-8 card">
            <h2 class="text-3xl font-bold mb-2">GraphRagの仕組みを体験する</h2>
            <p class="max-w-3xl mx-auto text-lg text-stone-700 mb-8">
                GraphRagは「ナレッジグラフの構築」と「グラフに基づく情報検索」の2つのフェーズで動作します。下のボタンを押して、そのプロセスをステップバイステップで見ていきましょう。
            </p>

            <div class="chart-container mb-6">
                <canvas id="graphCanvas"></canvas>
            </div>
            <p id="step-description" class="text-stone-600 h-12 mb-6 transition-opacity duration-500"></p>

            <div class="flex justify-center items-center space-x-4">
                <button id="reset-btn" class="btn btn-outline">リセット</button>
                <button id="next-step-btn" class="btn">スタート</button>
            </div>
        </section>

        <section id="benefits" class="mb-16 md:mb-24">
            <h2 class="text-3xl font-bold text-center mb-8">GraphRagがもたらす3つのメリット</h2>
            <div class="grid md:grid-cols-3 gap-8">
                <div class="p-6 card text-center">
                    <div class="text-4xl mb-4">🎯</div>
                    <h3 class="text-xl font-bold mb-2">回答の精度向上</h3>
                    <p class="text-stone-600">文脈や関係性を考慮するため、LLMの「幻覚（ハルシネーション）」を抑制し、事実に基づいた正確な回答を生成します。</p>
                </div>
                <div class="p-6 card text-center">
                    <div class="text-4xl mb-4">🧩</div>
                    <h3 class="text-xl font-bold mb-2">複雑な質問への対応</h3>
                    <p class="text-stone-600">複数の文書にまたがる情報や、間接的な関係を辿ることで、単純な検索では答えられない複雑な質問にも対応可能です。</p>
                </div>
                <div class="p-6 card text-center">
                    <div class="text-4xl mb-4">🗂️</div>
                    <h3 class="text-xl font-bold mb-2">効率的な情報整理</h3>
                    <p class="text-stone-600">膨大な情報を構造化されたグラフとして整理するため、必要な情報を素早く、かつ網羅的に見つけ出すことができます。</p>
                </div>
            </div>
        </section>

        <section id="use-cases" class="text-center bg-white p-8 rounded-lg shadow-inner">
            <h2 class="text-3xl font-bold mb-4">活用シーン</h2>
            <p class="max-w-3xl mx-auto text-lg text-stone-700">
                GraphRagは、高度な文脈理解が求められる様々な場面でその真価を発揮します。
            </p>
            <div class="mt-8 flex flex-wrap justify-center gap-4">
                <span class="bg-stone-200 text-stone-800 py-2 px-4 rounded-full font-semibold">企業内ナレッジ検索</span>
                <span class="bg-stone-200 text-stone-800 py-2 px-4 rounded-full font-semibold">学術論文の要約</span>
                <span class="bg-stone-200 text-stone-800 py-2 px-4 rounded-full font-semibold">法律文書の分析</span>
                <span class="bg-stone-200 text-stone-800 py-2 px-4 rounded-full font-semibold">金融市場の動向調査</span>
            </div>
        </section>

    </main>

    <footer class="text-center py-8 mt-12 border-t accent-border">
        <p class="text-stone-500">このページはGraphRagの概念を理解するために作成されたインタラクティブなデモンストレーションです。</p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const ctx = document.getElementById('graphCanvas').getContext('2d');
            const descriptionEl = document.getElementById('step-description');
            const nextStepBtn = document.getElementById('next-step-btn');
            const resetBtn = document.getElementById('reset-btn');

            let chart;
            let currentStep = 0;

            const initialData = {
                nodes: [
                    { id: 'doc1', label: '文書A', x: 100, y: 100, radius: 25, color: '#A8A29E' },
                    { id: 'doc2', label: '文書B', x: 400, y: 100, radius: 25, color: '#A8A29E' },
                    { id: 'doc3', label: '文書C', x: 250, y: 300, radius: 25, color: '#A8A29E' },
                ],
                edges: []
            };

            const steps = [
                {
                    description: "スタートボタンを押して、ナレッジグラフの構築を開始します。",
                    action: () => {
                        updateChart(initialData.nodes, []);
                        nextStepBtn.textContent = '1. エンティティ抽出';
                    }
                },
                {
                    description: "まず、各文書から重要なエンティティ（人、組織、概念など）を抽出します。",
                    action: () => {
                        const newNodes = [
                            ...initialData.nodes,
                            { id: 'ジェミ助', label: 'ジェミ助', x: 100, y: 200, radius: 15, color: '#60A5FA' },
                            { id: 'Google', label: 'Google', x: 200, y: 150, radius: 15, color: '#34D399' },
                            { id: 'LLM', label: 'LLM', x: 300, y: 200, radius: 15, color: '#FBBF24' },
                            { id: '2025年', label: '2025年', x: 400, y: 250, radius: 15, color: '#F87171' }
                        ];
                        updateChart(newNodes, []);
                        nextStepBtn.textContent = '2. 関係性定義';
                    }
                },
                {
                    description: "次に、エンティティ間の関係性を定義し、エッジ（線）で結びつけます。",
                    action: () => {
                        const nodes = chart.data.datasets[0].data.map(d => d);
                        const newEdges = [
                            { source: 'ジェミ助', target: 'Google', label: '開発者' },
                            { source: 'ジェミ助', target: 'LLM', label: '種類' },
                            { source: 'ジェミ助', target: '2025年', label: '開発年' }
                        ];
                        updateChart(nodes, newEdges);
                        nextStepBtn.textContent = '3. グラフ検索';
                    }
                },
                {
                    description: "「ジェミ助はいつ開発された？」という質問が来たと仮定し、グラフを検索します。",
                    action: () => {
                        const nodes = chart.data.datasets[0].data.map(d => {
                            if (['ジェミ助', '2025年'].includes(d.id)) {
                                return { ...d, radius: d.radius * 1.2, color: '#EF4444' };
                            }
                            return d;
                        });
                        const edges = chart.data.datasets[1].data.map(e => {
                            if (e.source === 'ジェミ助' && e.target === '2025年') {
                                return { ...e, color: '#EF4444' };
                            }
                            return e;
                        });
                        highlightPath(nodes, edges);
                        nextStepBtn.textContent = '4. コンテキスト収集';
                    }
                },
                {
                    description: "関連情報だけでなく、その周辺情報（開発者、種類など）も同時に収集し、文脈の豊かな回答を生成します。",
                    action: () => {
                         const nodes = chart.data.datasets[0].data.map(d => {
                            if (['ジェミ助', 'Google', 'LLM', '2025年'].includes(d.id)) {
                                return { ...d, radius: d.radius, color: '#EF4444' };
                            }
                            return d;
                        });
                        const edges = chart.data.datasets[1].data.map(e => {
                           if (e.source === 'ジェミ助') {
                                return { ...e, color: '#EF4444' };
                            }
                            return e;
                        });
                        highlightPath(nodes, edges);
                        nextStepBtn.textContent = '完了';
                        nextStepBtn.disabled = true;
                    }
                }
            ];

            function drawChart() {
                if (chart) {
                    chart.destroy();
                }
                chart = new Chart(ctx, {
                    type: 'bubble',
                    data: {
                        datasets: [
                            {
                                label: 'Nodes',
                                data: [],
                                backgroundColor: [],
                                borderColor: 'rgba(0,0,0,0.5)',
                                borderWidth: 1,
                            },
                            {
                                type: 'line',
                                label: 'Edges',
                                data: [],
                                fill: false,
                                borderColor: '#A8A29E',
                                borderWidth: 2,
                                pointRadius: 0,
                                showLine: true
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                enabled: true,
                                callbacks: {
                                    label: function(context) {
                                        if (context.dataset.label === 'Nodes') {
                                            return context.raw.label;
                                        }
                                        return null;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: { display: false, min: 0, max: 500 },
                            y: { display: false, min: 0, max: 400 }
                        },
                        animation: {
                            duration: 800
                        },
                        layout: {
                            padding: 20
                        }
                    },
                    plugins: [{
                        id: 'customCanvasDrawing',
                        afterDraw: (chart) => {
                            const ctx = chart.ctx;
                            ctx.save();
                            const nodeDataset = chart.data.datasets[0];
                            const edgeDataset = chart.data.datasets[1].data;

                            nodeDataset.data.forEach((point, index) => {
                                const meta = chart.getDatasetMeta(0);
                                const pos = meta.data[index].getCenterPoint();
                                ctx.fillStyle = '#44403C';
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                ctx.font = '12px "Inter"';
                                ctx.fillText(point.label, pos.x, pos.y);
                            });

                            edgeDataset.forEach(edge => {
                                const sourceNode = nodeDataset.data.find(n => n.id === edge.source);
                                const targetNode = nodeDataset.data.find(n => n.id === edge.target);
                                if (!sourceNode || !targetNode) return;

                                const sourceIndex = nodeDataset.data.indexOf(sourceNode);
                                const targetIndex = nodeDataset.data.indexOf(targetNode);
                                const sourcePos = chart.getDatasetMeta(0).data[sourceIndex].getCenterPoint();
                                const targetPos = chart.getDatasetMeta(0).data[targetIndex].getCenterPoint();

                                ctx.beginPath();
                                ctx.moveTo(sourcePos.x, sourcePos.y);
                                ctx.lineTo(targetPos.x, targetPos.y);
                                ctx.strokeStyle = edge.color || '#A8A29E';
                                ctx.lineWidth = 2;
                                ctx.stroke();

                                if (edge.label) {
                                    const midX = (sourcePos.x + targetPos.x) / 2;
                                    const midY = (sourcePos.y + targetPos.y) / 2;
                                    ctx.fillStyle = 'white';
                                    ctx.fillRect(midX - 25, midY - 10, 50, 20);
                                    ctx.fillStyle = '#44403C';
                                    ctx.fillText(edge.label, midX, midY);
                                }
                            });
                            ctx.restore();
                        }
                    }]
                });
            }
            
            function updateChart(nodes, edges) {
                chart.data.datasets[0].data = nodes.map(n => ({ x: n.x, y: n.y, r: n.radius, label: n.label, id: n.id }));
                chart.data.datasets[0].backgroundColor = nodes.map(n => n.color);

                const edgeLines = [];
                edges.forEach(edge => {
                    const sourceNode = nodes.find(n => n.id === edge.source);
                    const targetNode = nodes.find(n => n.id === edge.target);
                    if (sourceNode && targetNode) {
                        edgeLines.push({x: sourceNode.x, y: sourceNode.y}, {x: targetNode.x, y: targetNode.y}, {x: null, y: null});
                    }
                });
                chart.data.datasets[1].data = edges;
                chart.update();
            }
            
            function highlightPath(nodes, edges) {
                chart.data.datasets[0].data = nodes.map(n => ({ x: n.x, y: n.y, r: n.radius, label: n.label, id: n.id }));
                chart.data.datasets[0].backgroundColor = nodes.map(n => n.color);
                chart.data.datasets[1].data = edges;
                chart.update();
            }

            function runStep(stepIndex) {
                if (stepIndex < steps.length) {
                    const step = steps[stepIndex];
                    descriptionEl.style.opacity = 0;
                    setTimeout(() => {
                        descriptionEl.textContent = step.description;
                        step.action();
                        descriptionEl.style.opacity = 1;
                    }, 300);
                }
            }

            nextStepBtn.addEventListener('click', () => {
                runStep(currentStep);
                currentStep++;
            });

            resetBtn.addEventListener('click', () => {
                currentStep = 0;
                nextStepBtn.disabled = false;
                runStep(0);
            });
            
            drawChart();
            runStep(0);
        });
    </script>
</body>
</html>
